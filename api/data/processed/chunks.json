[
  {
    "id": "chunk_0",
    "text": "Assignment No-3\nName :- Ayaan Shaikh\nRoll No. :- C-42\nClass :- T.Y . B.Tech.\nAim :- To implement Breadth First Search (BFS) and Depth First Search (DFS)\nalgorithms to solve a given state-space problem and compare their time and\nspace complexity empirically.\nProblem Statement\nImplement BFS and DFS to solve a given state-space problem (e.g., maze\nnavigation or 8-puzzle). Compare time and space complexity empirically.\nDescription",
    "section": "General",
    "chunk_index": 0,
    "char_start": 0,
    "char_end": 430
  },
  {
    "id": "chunk_1",
    "text": "Description\nUninformed search algorithms explore the state space without using any\ndomain-specific knowledge. Among these, Breadth First Search (BFS) and\nDepth First Search (DFS) are fundamental techniques used to traverse graphs\nand trees.\nIn this assignment, BFS and DFS are implemented to solve a maze navigation\nproblem, which represents a state-space search problem. The performance of\nboth algorithms is analyzed and compared based on time and space usage.\nState-Space Problem: Maze Navigation",
    "section": "General",
    "chunk_index": 1,
    "char_start": 430,
    "char_end": 929
  },
  {
    "id": "chunk_2",
    "text": "State-Space Problem: Maze Navigation\nState Representation :-\n\u25cf Each state represents the current position (row, column) of the agent in\nthe maze.\nInitial State :-\n\u25cf Starting cell of the maze.\nGoal State :-\n\u25cf Destination cell of the maze.\nActions :-\n\u25cf Move Up, Down, Left, or Right (if not blocked).\nMaze Representation :-\n\u25cf 0 \u2192 Free cell\n\u25cf 1 \u2192 Obstacle\nMaze Structure\nmaze = [\n[0, 1, 0, 0, 0],\n[0, 1, 0, 1, 0],\n[0, 0, 0, 1, 0],\n[1, 1, 0, 0, 0],\n[0, 0, 0, 1, 0]\n]\nstart = (0, 0)\ngoal = (4, 4)",
    "section": "General",
    "chunk_index": 2,
    "char_start": 929,
    "char_end": 1420
  },
  {
    "id": "chunk_3",
    "text": "[0, 0, 0, 1, 0]\n]\nstart = (0, 0)\ngoal = (4, 4)\nAlgorithm 1: Breadth First Search (BFS)\nDescription :-\nBreadth First Search explores the state space level by level using a queue. It is\ncomplete and guarantees the shortest path in an unweighted graph.\nPython Implementation :-\nfromcollectionsimport deque\ndefbfs(maze,start,goal):\nqueue=deque([(start, [start])])\nvisited=set([start])\nnodes_expanded= 0\nwhilequeue:\n(x,y),path=queue.popleft()\nnodes_expanded += 1\nif(x,y)==goal:\nreturnpath,nodes_expanded",
    "section": "General",
    "chunk_index": 3,
    "char_start": 1420,
    "char_end": 1918
  },
  {
    "id": "chunk_4",
    "text": "if(x,y)==goal:\nreturnpath,nodes_expanded\nfordx,dyin[(-1,0),(1,0),(0,-1),(0,1)]:\nnx,ny=x+dx, y + dy\nif0<=nx<len(maze) and 0 <= ny < len(maze[0]):\nifmaze[nx][ny] == 0 and (nx, ny) not in visited:\nvisited.add((nx, ny))\nqueue.append(((nx, ny), path + [(nx, ny)]))\nreturnNone,nodes_expanded\nObservation (BFS) :-\n\u25cf BFS explores many nodes.\n\u25cf Requires more memory due to queue storage.\n\u25cf Always finds the shortest path.\nAlgorithm 2: Depth First Search (DFS)\nDescription :-",
    "section": "General",
    "chunk_index": 4,
    "char_start": 1918,
    "char_end": 2383
  },
  {
    "id": "chunk_5",
    "text": "Description :-\nDepth First Search explores as deep as possible along one path before\nbacktracking. It uses a stack or recursion and requires less memory than BFS.\nPython Implementation :-\ndefdfs(maze,start,goal):\nstack=[(start,[start])]\nvisited=set([start])\nnodes_expanded= 0\nwhilestack:\n(x,y),path=stack.pop()\nnodes_expanded += 1\nif(x,y)==goal:\nreturnpath,nodes_expanded\nfordx,dyin[(-1,0),(1,0),(0,-1),(0,1)]:\nnx,ny=x+dx, y + dy\nif0<=nx<len(maze) and 0 <= ny < len(maze[0]):",
    "section": "General",
    "chunk_index": 5,
    "char_start": 2383,
    "char_end": 2858
  },
  {
    "id": "chunk_6",
    "text": "if0<=nx<len(maze) and 0 <= ny < len(maze[0]):\nifmaze[nx][ny] == 0 and (nx, ny) not in visited:\nvisited.add((nx, ny))\nstack.append(((nx, ny), path + [(nx, ny)]))\nreturnNone,nodes_expanded\nObservation (DFS) :-\n\u25cf DFS uses less memory.\n\u25cf May explore unnecessary deep paths.\n\u25cf Does not guarantee shortest path.\nEmpirical Performance Comparison :-\nbfs_path, bfs_nodes = bfs(maze, start, goal)\ndfs_path, dfs_nodes = dfs(maze, start, goal)\nprint(\"BFS Nodes Expanded:\", bfs_nodes)",
    "section": "General",
    "chunk_index": 6,
    "char_start": 2858,
    "char_end": 3329
  },
  {
    "id": "chunk_7",
    "text": "print(\"BFS Nodes Expanded:\", bfs_nodes)\nprint(\"DFS Nodes Expanded:\", dfs_nodes)\nPerformance Comparison Table :-\nCriteria BFS DFS\nData Structure Queue Stack\nNodes Higher Lower\nExpanded\nHigh Low\nMemory Usage\nCompleteness Yes No\nOptimal Yes No\nSolution\nExecution Slower Faster\nSpeed\nOutput Analysis :-\n\u25cf BFS expands more nodes but guarantees the shortest path.\n\u25cf DFS expands fewer nodes but may take a longer or sub-optimal route.\n\u25cf BFS consumes more memory, while DFS is space-efficient.\nConclusion",
    "section": "General",
    "chunk_index": 7,
    "char_start": 3329,
    "char_end": 3825
  },
  {
    "id": "chunk_8",
    "text": "Conclusion\nThis assignment successfully implements BFS and DFS algorithms to solve a\nmaze navigation problem. BFS is complete and optimal but requires more\nmemory. DFS is memory-efficient but does not guarantee the shortest path. The\nempirical comparison highlights the trade-off between time, space, and optimality\nin uninformed search algorithms.",
    "section": "General",
    "chunk_index": 8,
    "char_start": 3825,
    "char_end": 4173
  }
]